// wuw – https://github.com/fasttime/wuw
"use strict";{const e=CSSStyleDeclaration.prototype.item,t=Error,r=t.captureStackTrace,n=Intl.ListFormat,o=JSON.stringify,s=Math.floor,a=Node.prototype.hasChildNodes,l=Object,{create:c,defineProperties:i,defineProperty:u,freeze:g,getOwnPropertyDescriptors:d,getOwnPropertyNames:f,getOwnPropertySymbols:p}=l,m=Proxy,y=m.revocable,w=RangeError,{defineProperty:h,deleteProperty:k,get:b,getPrototypeOf:v,setPrototypeOf:T,set:P}=Reflect,L=Set,x=String,S=Symbol,C=TypeError,$=console,{error:_,groupCollapsed:A,groupEnd:E,log:M,warn:O}=$,N="object"==typeof module?require("perf_hooks").performance:performance,R=e=>"string"==typeof e?o(e):o(x(e)).slice(1,-1),j=(e,t,r)=>u(e,t,{configurable:!0,value:r}),I=(e,t,r)=>{const n=i((...e)=>{try{return G=o,r(...e)}finally{G=void 0}},{length:{configurable:!0,value:r.length},name:{configurable:!0,value:t}}),o=K(e,t,n).join(".");return n},K=(e,t,r)=>{const n=(D.get(e)||[]).concat(t);return D.set(r,n),j(e,t,r),n},U=(e,t,r,n)=>u(e,t,{configurable:!0,get:r,set:n});let G,D=new Map;const W=()=>q.forEach(e=>e()),q=[],{installCallback:z,isCallbackInstalled:F,notify:J,uninstallAllCallbacks:B,uninstallCallback:H}=(()=>{const e=()=>t.clear(),t=new L;return q.push(e),{installCallback:e=>t.add(e),isCallbackInstalled:e=>t.has(e),notify:e=>{for(const r of t)try{r(e)}catch(e){_(e)}},uninstallAllCallbacks:e,uninstallCallback:e=>t.delete(e)}})(),Q={},V=(()=>{const n=(()=>{const e=r?e=>{const t={};return r(t,e),t.stack.replace(/^.{5}\n/,"")}:e=>Y(e,t());return"stackTraceLimit"in t?r=>{const{stackTraceLimit:n}=t;t.stackTraceLimit=1/0;const o=e(r);return t.stackTraceLimit=n,o}:e})(),o=({wuwTarget:e})=>{const t=H.get(e);if(t){if(t.wuwGeneration===V)return!0;l(e,t)}return!1},s=(e,t)=>{const r=v(e);return T(e,v(t)),r},l=(e,{mirror:t,revoke:r})=>{r();const n=d(t);M(e,n),T(e,v(t)),H.delete(e)},u=e=>[...f(e),...p(e)],w=e=>{try{a.call(e)}catch(e){return!1}return!0},x=()=>{V=S()},$=()=>N.now(),_={splitStackTrace(){return this.stackTrace.replace(/\n$/,"").split(Z)}},A=(e,t,r,s)=>{const a=B.get(e);return a&&a.spy===s?(o(a)?(e,t,r)=>{const o={__proto__:_,target:e,propertyKey:t,stackTrace:n(A),startTime:$()};let s,a;try{s=P(e,t,r),o.success=s}catch(e){a=e,o.error=a}if(o.endTime=$(),g(o),J(o),void 0!==a)throw a;return s}:P)(e,t,r):P(e,t,r,s)},E=(e,t)=>{const r=d(e),n=u(r).filter(n=>!(r[n].configurable&&k(e,n)||(delete r[n],t.has(n)||(t.add(n),0))));return n.length&&X&&X(e,n),r},M=(e,t)=>{const r=u(t);for(const n of r)h(e,n,t[n])},O=e=>{if(void 0===e)throw C(`Argument of ${G} is missing or undefined`);if(!w(e))throw C(`Argument of ${G} does not implement interface Node`);const t=H.get(e);return t&&l(e,t),W},R=()=>(x(),W),U=e=>{if(void 0===e)throw C(`Argument of ${G} is missing or undefined`);if(!w(e))throw C(`Argument of ${G} does not implement interface Node`);const t=H.get(e);if(!t||t.wuwGeneration!==V){t&&l(e,t);const r=new L,n=E(e,r),o=c(v(e),n),{proxy:s,revoke:a}=y(o,F);T(e,s),H.set(e,{mirror:o,remarkedPropertyKeys:r,revoke:a,wuwGeneration:V})}return W},D=(e,t,r,o)=>{const a=H.get(o);if(a&&e===a.mirror){if(a.wuwGeneration===V)return((e,t,r,o,a)=>{const l={__proto__:_,target:a,propertyKey:r,stackTrace:n(D),startTime:$()},c=s(a,t);let u,d;try{u=P(t,r,o,a),l.success=u}catch(e){d=e,l.error=d}const f=E(a,e.remarkedPropertyKeys);if(i(t,f),T(a,c),l.endTime=$(),g(l),J(l),void 0!==d)throw d;return u})(a,e,t,r,o);l(o,a)}return P(e,t,r,o)},W=I("undefined"==typeof self?global:self,"wuw",U),z={get:(e,t,r)=>{const n=B.get(e);return n&&n.spy===r&&(o(n),r=e),b(e,t,r)},set:A},F={get:(t,r,n)=>{const o=H.get(n);if(o&&t===o.mirror){if(o.wuwGeneration===V)return((t,r,n)=>{const o=s(n,t);let a;try{a=b(t,r,n)}finally{T(n,o)}return((t,r,n)=>{if("style"===r&&(t=>{try{e.call(t,-1)}catch(e){return!1}return!0})(n)){let e=B.get(n);if(e)n=e.spy;else{const r=new m(n,z);e={spy:r,wuwTarget:t},B.set(n,e),n=r}}return n})(n,r,a)})(t,r,n);l(n,o)}return b(t,r,n)},set:D},B=new WeakMap,H=new WeakMap;let V,Y,Z;q.push(x);{let e;r?e=!0:(Y=((t,r)=>{const{1:n,index:o}=r.stack.match(/^(    ?at )?0\b/m);t.stackTraceOffset=o,e=n}),{0(){const e={},t=new m(e,F);H.set(t,{mirror:e}),t._=null;const r=new m(e,z);B.set(e,{spy:r,wuwTarget:t}),r._=null}}[0](),Y=((e,t)=>t.stack.slice(e.stackTraceOffset))),Z=e?/(?:^|\n)(?=    ?at )/g:"\n"}return j(W,"toString",()=>"wuw"),K(W,"watching",Q),I(W,"watch",U),I(W,"unwatch",O),I(W,"unwatchAll",R),I(Q,"watch",U),I(Q,"unwatch",O),I(Q,"unwatchAll",R),W})();let X;{const e=u((e,r)=>{const n=t(r.map(R));O("The target object %o has undeletable properties: %s",e,n)},"name",{configurable:!0,value:"remarkUndeletableProperties"}),t=n?(()=>{const e=new n("en");return t=>e.format(t)})():e=>{const{length:t}=e;return t>2?`${e.slice(0,-1).join(", ")}, and ${e[t-1]}`:e.join(" and ")},r=()=>X,o=e=>{if(void 0!==e&&null!==e&&"function"!=typeof e)throw C("remarkUndeletableProperties must be a function, undefined or null");X=e||null};q.push(()=>{X=e}),j(V,"defaultRemarkUndeletableProperties",e),U(V,"remarkUndeletableProperties",r,o),j(Q,"defaultRemarkUndeletableProperties",e),U(Q,"remarkUndeletableProperties",r,o)}const Y={};{const e=e=>(o(e),z(e),V),t=()=>(B(),V),r=e=>(o(e),H(e),V),n=e=>(o(e),F(e)),o=e=>{if(void 0===e)throw C(`Argument of ${G} is missing or undefined`);if("function"!=typeof e)throw C(`Argument of ${G} is not a function`)};K(V,"doing",Y),I(V,"do",e),I(V,"dont",r),I(V,"doNothing",t),I(V,"isDoing",n),I(Y,"do",e),I(Y,"dont",r),I(Y,"doNothing",t),I(Y,"isDoing",n)}const Z={};{const e=()=>(r(),V),t=1e4,r=()=>{m=y={next:null},h=0},n=()=>h,o=()=>F(i),a=()=>k,l=function*(){for(let e,t=m;e=t.next;({slot:t}=e))yield e.record},c={},i=e=>{const t={next:null};y.next={record:e,slot:t},y=t,h<k?++h:m=m.next.slot},g=e=>(e?z:H)(i),d=e=>{if((e=+e)<0||e!==s(e))throw w("Invalid log length");for(k=e+0;h>k;)m=m.next.slot,--h},f=()=>{const e=[];for(let t,r=m;t=r.next;({slot:r}=t))e.push(t.record);return e},p=u(()=>l(),"name",{configurable:!0,value:"values"});let m,y,h,k;q.push(()=>{r(),k=t,z(i)}),K(V,"logging",Z),j(V,"log",c),I(V,"snapshot",f),I(V,"clearLog",e),U(V,"loggingEnabled",o,g),j(V,"defaultMaxLogLength",t),U(V,"maxLogLength",a,d),j(Z,"log",c),I(Z,"snapshot",f),I(Z,"clearLog",e),U(Z,"loggingEnabled",o,g),j(Z,"defaultMaxLogLength",t),U(Z,"maxLogLength",a,d),U(c,"length",n),j(c,S.iterator,p)}const ee={};{const e="background: dodgerblue; border-radius: .2em; color: white; padding: 0 1em;",t=()=>{for(;;){const e=u.shift();if(!e)break;a(e)}u=null},r="undefined"!=typeof setImmediate?()=>setImmediate(t):(()=>{const{port1:e,port2:r}=new MessageChannel;return e.onmessage=t,()=>r.postMessage(null)})(),n=()=>F(s),o=()=>(z(s),V),s=e=>{u?u.push(e):(r(),u=[e])},a=$.markTimeline?(()=>{const t=(e,t)=>{const r=e.padEnd(13," ");l(t)!==t?(A(`${r} ${t}`),E()):M(r,t,"…")};return r=>{M("%cwuw record",e),t("target",r.target),t("property key",R(r.propertyKey)),t("stack trace",r.splitStackTrace()),t("start time",r.startTime),t("end time",r.endTime);const{error:n}=r;void 0===n?t("success",r.success):t("error",n)}})():t=>{const r="color: slategrey; font-family: Menlo, monospace;",{error:n}=t;let o,s;void 0===n?(o="success       ",s=t.success):(o="error         ",s=n),M("%cwuw record%c\n%c%s%o\n%c%s%c%s\n%c%s%o\n%c%s%o\n%c%s%o\n%c%s%c%o",e,"",r,"target        ",t.target,r,"property key  ","",R(t.propertyKey),r,"stack trace   ",t.splitStackTrace(),r,"start time    ",t.startTime,r,"end time      ",t.endTime,r,o,"",s)},c=e=>(e?z:H)(s),i=()=>(H(s),V);let u=null;K(V,"liveReporting",ee),I(V,"live",o),I(V,"unlive",i),U(V,"liveReportingEnabled",n,c),I(ee,"live",o),I(ee,"unlive",i),U(ee,"liveReportingEnabled",n,c)}I(V,"reset",()=>(W(),V)),D=null,W()}