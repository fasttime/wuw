// wuw â€“ https://github.com/fasttime/wuw
"use strict";{const e=CSSStyleDeclaration.prototype.item,t=Error,r=t.captureStackTrace,n=Intl.ListFormat,o=JSON.stringify,s=Math.floor,a=Node.prototype.hasChildNodes,{create:l,defineProperties:i,defineProperty:c,freeze:u,getOwnPropertyDescriptors:f,getOwnPropertyNames:g,getOwnPropertySymbols:d}=Object,p=Proxy,m=p.revocable,h=RangeError,{defineProperty:w,deleteProperty:y,get:k,getPrototypeOf:b,setPrototypeOf:v,set:P}=Reflect,T=Set,L=String,x=Symbol,A=TypeError,{error:$,log:C,warn:O}=console,S="object"==typeof module?require("perf_hooks").performance:performance,M=(e,t,r)=>c(e,t,{configurable:!0,value:r}),N=(e,t,r)=>{const n=i((...e)=>{try{return G=o,r(...e)}finally{G=void 0}},{length:{configurable:!0,value:r.length},name:{configurable:!0,value:t}}),o=j(e,t,n).join(".");return n},j=(e,t,r)=>{const n=(E.get(e)||[]).concat(t);return E.set(r,n),M(e,t,r),n},U=(e,t,r,n)=>c(e,t,{configurable:!0,get:r,set:n});let G,E=new Map;const I=e=>e.forEach(e=>e()),K=[],R=[],{installCallback:_,notify:D,uninstallAllCallbacks:W,uninstallCallback:q}=(()=>{const e=()=>t.clear(),t=new T;return K.push(e),{installCallback:e=>t.add(e),notify:e=>{for(const r of t)try{r(e)}catch(e){$(e)}},uninstallAllCallbacks:e,uninstallCallback:e=>t.delete(e)}})(),z={},F=(()=>{const n=(()=>{const e=r?e=>{const t={};return r(t,e),t.stack.replace(/^.{5}\n/,"")}:e=>V(e,t());return"stackTraceLimit"in t?r=>{const{stackTraceLimit:n}=t;t.stackTraceLimit=1/0;const o=e(r);return t.stackTraceLimit=n,o}:e})(),o=({wuwTarget:e})=>{const t=H.get(e);if(t){if(t.wuwGeneration===Q)return!0;c(e,t)}return!1},s=(e,t)=>{const r=b(e);return v(e,b(t)),r},c=(e,{mirror:t,revoke:r})=>{r();const n=f(t);U(e,n),v(e,b(t)),H.delete(e)},h=e=>[...g(e),...d(e)],L=e=>{try{a.call(e)}catch(e){return!1}return!0},$=()=>{Q=x()},C=()=>S.now(),O=(e,t,r,s)=>{const a=B.get(e);return a&&a.spy===s?(o(a)?(e,t,r)=>{const o={target:e,propertyKey:t,stackTrace:n(O),startTime:C()};let s,a;try{s=P(e,t,r),o.success=s}catch(e){a=e,o.error=a}if(o.endTime=C(),u(o),D(o),void 0!==a)throw a;return s}:P)(e,t,r):P(e,t,r,s)},M=(e,t)=>{const r=f(e),n=h(r).filter(n=>!(r[n].configurable&&y(e,n)||(delete r[n],t.has(n)||(t.add(n),0))));return n.length&&J&&J(e,n),r},U=(e,t)=>{const r=h(t);for(const n of r)w(e,n,t[n])},E=e=>{if(void 0===e)throw A(`Argument of ${G} is missing or undefined`);if(!L(e))throw A(`Argument of ${G} does not implement interface Node`);const t=H.get(e);return t&&c(e,t),W},I=()=>($(),W),K=e=>{if(void 0===e)throw A(`Argument of ${G} is missing or undefined`);if(!L(e))throw A(`Argument of ${G} does not implement interface Node`);const t=H.get(e);if(!t||t.wuwGeneration!==Q){t&&c(e,t);const r=new T,n=M(e,r),o=l(b(e),n),{proxy:s,revoke:a}=m(o,F);v(e,s),H.set(e,{mirror:o,remarkedPropertyKeys:r,revoke:a,wuwGeneration:Q})}return W},_=(e,t,r,o)=>{const a=H.get(o);if(a&&e===a.mirror){if(a.wuwGeneration===Q)return(({remarkedPropertyKeys:e},t,r,o,a)=>{const l={target:a,propertyKey:r,stackTrace:n(_),startTime:C()},c=s(a,t);let f,g;try{f=P(t,r,o,a),l.success=f}catch(e){g=e,l.error=g}const d=M(a,e);if(i(t,d),v(a,c),l.endTime=C(),u(l),D(l),void 0!==g)throw g;return f})(a,e,t,r,o);c(o,a)}return P(e,t,r,o)},W=N("undefined"==typeof self?global:self,"wuw",K),q={get:(e,t,r)=>{const n=B.get(e);return n&&n.spy===r&&(o(n),r=e),k(e,t,r)},set:O},F={get:(t,r,n)=>{const o=H.get(n);if(o&&t===o.mirror){if(o.wuwGeneration===Q)return((t,r,n)=>{const o=s(n,t);let a;try{a=k(t,r,n)}finally{v(n,o)}return((t,r,n)=>{if("style"===r&&(t=>{try{e.call(t,-1)}catch(e){return!1}return!0})(n)){let e=B.get(n);if(e)n=e.spy;else{const r=new p(n,q);e={spy:r,wuwTarget:t},B.set(n,e),n=r}}return n})(n,r,a)})(t,r,n);c(n,o)}return k(t,r,n)},set:_},B=new WeakMap,H=new WeakMap;let Q,V;return R.push($),r||(V=((e,{stack:t})=>{e.stackTraceOffset=t.search(/^(?: *at )?0\b/m)}),{0(){const e={},t=new p(e,F);H.set(t,{mirror:e}),t._=null;const r=new p(e,q);B.set(e,{spy:r,wuwTarget:t}),r._=null}}[0](),V=((e,{stack:t})=>t.slice(e.stackTraceOffset))),j(W,"watching",z),N(W,"watch",K),N(W,"unwatch",E),N(W,"unwatchAll",I),N(z,"watch",K),N(z,"unwatch",E),N(z,"unwatchAll",I),W})();let J;{const e=c((e,n)=>{const o=t(n.map(r));O("The target object %o has undeletable properties: %s",e,o)},"name",{configurable:!0,value:"remarkUndeletableProperties"}),t=n?(()=>{const e=new n("en");return t=>e.format(t)})():e=>{const{length:t}=e;return t>2?`${e.slice(0,-1).join(", ")}, and ${e[t-1]}`:e.join(" and ")},r=e=>("string"==typeof e?o:L)(e),s=()=>J,a=e=>{if(void 0!==e&&null!==e&&"function"!=typeof e)throw A("remarkUndeletableProperties must be a function, undefined or null");J=e||null};R.push(()=>{J=e}),M(F,"defaultRemarkUndeletableProperties",e),U(F,"remarkUndeletableProperties",s,a),M(z,"defaultRemarkUndeletableProperties",e),U(z,"remarkUndeletableProperties",s,a)}const B={};{const e=e=>{if(void 0===e)throw A(`Argument of ${G} is missing or undefined`);if("function"!=typeof e)throw A(`Argument of ${G} is not a function`);return _(e),F},t=()=>(W(),F),r=e=>{if(void 0===e)throw A(`Argument of ${G} is missing or undefined`);if("function"!=typeof e)throw A(`Argument of ${G} is not a function`);return q(e),F};j(F,"doing",B),N(F,"do",e),N(F,"dont",r),N(F,"doNothing",t),N(B,"do",e),N(B,"dont",r),N(B,"doNothing",t)}const H={};{const e=()=>(r(),F),t=1e4,r=()=>{d=null,p=null,m=0},n=()=>m,o=()=>w,a=function*(){for(let e=d;e;e=e.next)yield e.record},l={},i=e=>{if(w){const t={record:e,next:null};p=p?p.next=t:d=t,m<w?++m:d=d.next}},u=e=>{if((e=+e)<0||e!==s(e))throw h("Invalid log length");for(w=e+0;m>w;)d===p&&(p=null),d=d.next,--m},f=()=>{const e=[];for(let t=d;t;t=t.next)e.push(t.record);return e},g=c(()=>a(),"name",{configurable:!0,value:"values"});let d,p,m,w;R.push(()=>{r(),w=t,_(i)}),j(F,"logging",H),M(F,"log",l),N(F,"snapshot",f),N(F,"clearLog",e),M(F,"defaultMaxLogLength",t),U(F,"maxLogLength",o,u),M(H,"log",l),N(H,"snapshot",f),N(H,"clearLog",e),M(H,"defaultMaxLogLength",t),U(H,"maxLogLength",o,u),U(l,"length",n),M(l,x.iterator,g)}{const e=()=>{for(;;){const e=s.shift();if(!e)break;C("wuw record\n%o",e)}s=null},t="undefined"!=typeof setImmediate?()=>{setImmediate(e)}:(()=>{const{port1:t,port2:r}=new MessageChannel;return t.onmessage=e,()=>r.postMessage()})(),r=()=>(q(o),F),n=()=>(_(o),F),o=e=>{s?s.push(e):(s=[e],t())};let s=null;{const e=()=>n();N(e,"on",n),N(e,"off",r),N(F,"live",e)}}N(F,"reset",()=>(I(K),I(R),F)),E=null,I(R)}