// wuw â€“ https://github.com/fasttime/wuw
"use strict";{const e=CSSStyleDeclaration.prototype.item,t=Error,r=t.captureStackTrace,n=Intl.ListFormat,o=JSON.stringify,s=Math.floor,c=Math.max,i=Node.prototype.hasChildNodes,a=Object.create,l=Object.defineProperties,u=Object.defineProperty,f=Object.freeze,d=Object.getOwnPropertyDescriptors,p=Object.getOwnPropertyNames,g=Object.getOwnPropertySymbols,m=Proxy,h=m.revocable,w=RangeError,y=Reflect.defineProperty,b=Reflect.deleteProperty,k=Reflect.get,v=Reflect.getPrototypeOf,P=Reflect.setPrototypeOf,T=Reflect.set,O=Set,j=String,A=Symbol,R=TypeError,$=console.error,C=console.log,S=console.warn,M="object"==typeof module?require("perf_hooks").performance:performance,N=(e,t,r)=>u(e,t,{configurable:!0,value:r}),x=(e,t,r)=>{const n=l((...e)=>{try{return L=o,r(...e)}finally{L=void 0}},{length:{configurable:!0,value:r.length},name:{configurable:!0,value:t}}),o=E(e,t,n).join(".");return n},E=(e,t,r)=>{const n=(U.get(e)||[]).concat(t);return U.set(r,n),N(e,t,r),n},G=(e,t,r,n)=>u(e,t,{configurable:!0,get:r,set:n});let L,U=new Map;const I=e=>e.forEach(e=>e()),K=[],D=[],{installCallback:W,notify:q,uninstallAllCallbacks:z,uninstallCallback:F}=(()=>{const e=()=>t.clear(),t=new O;return K.push(e),{installCallback:e=>t.add(e),notify:e=>{for(const r of t)try{r(e)}catch(e){$(e)}},uninstallAllCallbacks:e,uninstallCallback:e=>t.delete(e)}})(),J={},_=(()=>{const n=(()=>{const e=r?e=>{const t={};return r(t,e),t.stack.replace(/^.{5}\n/,"")}:()=>t().stack.replace(/^(Error\n)?(?:.*\n){4}/,"");return"stackTraceLimit"in t?r=>{const{stackTraceLimit:n}=t;t.stackTraceLimit=1/0;const o=e(r);return t.stackTraceLimit=n,o}:t=>e(t)})(),o=({wuwTarget:e})=>{const t=H.get(e);if(t){if(t.wuwGeneration===Q)return!0;c(e,t)}return!1},s=(e,t)=>{const r=v(e);return P(e,v(t)),r},c=(e,{mirror:t,revoke:r})=>{r();const n=d(t);N(e,n),P(e,v(t)),H.delete(e)},u=e=>[...p(e),...g(e)],w=e=>{try{i.call(e)}catch(e){return!1}return!0},j=()=>{Q=A()},$=()=>M.now(),C=(e,t,r,s)=>{const c=_.get(e);return c&&c.spy===s?(o(c)?(e,t,r)=>{const o={target:e,propertyKey:t,stackTrace:n(C),startTime:$()};let s,c;try{s=T(e,t,r),o.success=s}catch(e){c=e,o.error=c}if(o.endTime=$(),f(o),q(o),void 0!==c)throw c;return s}:T)(e,t,r):T(e,t,r,s)},S=(e,t)=>{const r=d(e),n=u(r).filter(n=>!(r[n].configurable&&b(e,n)||(delete r[n],t.has(n)||(t.add(n),0))));return n.length&&B&&B(e,n),r},N=(e,t)=>{const r=u(t);for(const n of r)y(e,n,t[n])},G=e=>{if(void 0===e)throw R(`Argument of ${L} is missing or undefined`);if(!w(e))throw R(`Argument of ${L} does not implement interface Node`);const t=H.get(e);return t&&c(e,t),W},U=()=>(j(),W),I=e=>{if(void 0===e)throw R(`Argument of ${L} is missing or undefined`);if(!w(e))throw R(`Argument of ${L} does not implement interface Node`);const t=H.get(e);if(!t||t.wuwGeneration!==Q){t&&c(e,t);const r=new O,n=S(e,r),o=a(v(e),n),{proxy:s,revoke:i}=h(o,F);P(e,s),H.set(e,{mirror:o,remarkedPropertyKeys:r,revoke:i,wuwGeneration:Q})}return W},K=(e,t,r,o)=>{const i=H.get(o);if(i&&e===i.mirror){if(i.wuwGeneration===Q)return(({remarkedPropertyKeys:e},t,r,o,c)=>{const i={target:c,propertyKey:r,stackTrace:n(K),startTime:$()},a=s(c,t);let u,d;try{u=T(t,r,o,c),i.success=u}catch(e){d=e,i.error=d}const p=S(c,e);if(l(t,p),P(c,a),i.endTime=$(),f(i),q(i),void 0!==d)throw d;return u})(i,e,t,r,o);c(o,i)}return T(e,t,r,o)},W=x("undefined"==typeof self?global:self,"wuw",I),z={get:(e,t,r)=>{const n=_.get(e);return n&&n.spy===r&&(o(n),r=e),k(e,t,r)},set:C},F={get:(t,r,n)=>{const o=H.get(n);if(o&&t===o.mirror){if(o.wuwGeneration===Q)return((t,r,n)=>{const o=s(n,t);let c;try{c=k(t,r,n)}finally{P(n,o)}return((t,r,n)=>{if("style"===r&&(t=>{try{e.call(t,-1)}catch(e){return!1}return!0})(n)){let e=_.get(n);if(e)n=e.spy;else{const r=new m(n,z);e={spy:r,wuwTarget:t},_.set(n,e),n=r}}return n})(n,r,c)})(t,r,n);c(n,o)}return k(t,r,n)},set:K},_=new WeakMap,H=new WeakMap;let Q;return D.push(j),E(W,"watching",J),x(W,"watch",I),x(W,"unwatch",G),x(W,"unwatchAll",U),x(J,"watch",I),x(J,"unwatch",G),x(J,"unwatchAll",U),W})();let B;{const e=(e,n)=>{const o=t(n.map(r));S("The target object %o has undeletable properties: %s",e,o)},t=n?(()=>{const e=new n("en");return t=>e.format(t)})():e=>{const{length:t}=e;return t>2?`${e.slice(0,-1).join(", ")}, and ${e[t-1]}`:e.join(" and ")},r=e=>("string"==typeof e?o:j)(e),s=()=>B,c=e=>{if(void 0!==e&&null!==e&&"function"!=typeof e)throw R("remarkUndeletableProperties must be a function, undefined or null");B=e||null};B=e,N(_,"defaultRemarkUndeletableProperties",e),G(_,"remarkUndeletableProperties",s,c),N(J,"defaultRemarkUndeletableProperties",e),G(J,"remarkUndeletableProperties",s,c)}const H={};{const e=e=>{if(void 0===e)throw R(`Argument of ${L} is missing or undefined`);if("function"!=typeof e)throw R(`Argument of ${L} is not a function`);return W(e),_},t=()=>(z(),_),r=e=>{if(void 0===e)throw R(`Argument of ${L} is missing or undefined`);if("function"!=typeof e)throw R(`Argument of ${L} is not a function`);return F(e),_};E(_,"doing",H),x(_,"do",e),x(_,"dont",r),x(_,"doNothing",t),x(H,"do",e),x(H,"dont",r),x(H,"doNothing",t)}{let e=0;const t=1e4,r=[],n=()=>{e=0,r.splice(0,1/0)},o=()=>t;function*log(){for(;e<r.length;)yield r[e++]}const i=n=>{r.length>=t&&(e&&--e,r.shift()),r.push(n)},a=n=>{if((n=+n)<0||n!==s(n))throw w("Invalid number of records");t=n+0;const o=r.length-t;o>0&&(e=c(e-o,0),r.splice(0,o))},l=()=>r.slice();K.push(n),D.push(()=>W(i)),x(_,"clear",n),N(_,"defaultMaxRecords",t),x(_,"log",log),G(_,"maxRecords",o,a),x(_,"snapshot",l)}{const e=()=>{for(;;){const e=s.shift();if(!e)break;C("wuw record\n%o",e)}s=null},t="undefined"!=typeof setImmediate?()=>{setImmediate(e)}:(()=>{const{port1:t,port2:r}=new MessageChannel;return t.onmessage=e,()=>r.postMessage()})(),r=()=>(F(o),_),n=()=>(W(o),_),o=e=>{s?s.push(e):(s=[e],t())};let s=null;{const e=()=>n();x(e,"on",n),x(e,"off",r),x(_,"live",e)}}x(_,"reset",()=>(I(K),I(D),_)),U=null,I(D)}