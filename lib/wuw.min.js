// wuw â€“ https://github.com/fasttime/wuw
"use strict";{const e=CSSStyleDeclaration.prototype.item,t=Error,n=t.captureStackTrace,r=JSON.stringify,o=Math.floor,i=Math.max,c=Node.prototype.hasChildNodes,f=Object.create,a=Object.defineProperties,s=Object.defineProperty,u=Object.freeze,l=Object.getOwnPropertyDescriptors,d=Object.getOwnPropertyNames,p=Object.getOwnPropertySymbols,g=Proxy,m=g.revocable,y=RangeError,w=Reflect.defineProperty,h=Reflect.deleteProperty,b=Reflect.get,k=Reflect.getPrototypeOf,R=Reflect.setPrototypeOf,P=Reflect.set,v=Set,F=String,L=Symbol,T=TypeError,O=console.error,C=console.log,M=console.warn,U="object"==typeof module?require("perf_hooks").performance:performance;let j,A=new Map;function defineConstant(e,t,n){s(e,t,{configurable:!0,value:n})}function defineFunction(e,t,n){const r=a((...e)=>{try{return j=o,n(...e)}finally{j=void 0}},{length:{configurable:!0,value:n.length},name:{configurable:!0,value:t}}),o=defineInterface(e,t,r).join(".");return r}function defineInterface(e,t,n){const r=(A.get(e)||[]).concat(t);return A.set(n,r),defineConstant(e,t,n),r}function defineVariable(e,t,n,r){s(e,t,{configurable:!0,get:n,set:r})}const{installCallback:$,notify:x,uninstallCallback:S}=(()=>{const e=new v;return{installCallback:function(t){e.add(t)},notify:function(t){for(const n of e)try{n(t)}catch(e){O(e)}},uninstallCallback:function(t){e.delete(t)}}})();let I;const K={},N=(()=>{function r({wuwTarget:e}){const t=E.get(e);if(t){if(t.wuwGeneration===V)return!0;i(e,t)}return!1}function o(e,t){const n=k(e);return R(e,k(t)),n}function i(e,{mirror:t,revoke:n}){n(),function(e,t){const n=s(t);for(const r of n)w(e,r,t[r])}(e,l(t)),R(e,k(t)),E.delete(e)}function s(e){return[...d(e),...p(e)]}function y(e){try{c.call(e)}catch(e){return!1}return!0}function F(){return U.now()}function O(e,t){const n=l(e),r=s(n).filter(r=>!(n[r].configurable&&h(e,r)||(delete n[r],t.has(r)||(t.add(r),0))));return r.length&&I&&I(e,r),n}function C(e){if(void 0===e)throw T(`Argument of ${j} is missing or undefined`);if(!y(e))throw T(`Argument of ${j} does not implement interface Node`);const t=E.get(e);return t&&i(e,t),$}function M(){return V=L(),$}function A(e){if(void 0===e)throw T(`Argument of ${j} is missing or undefined`);if(!y(e))throw T(`Argument of ${j} does not implement interface Node`);const t=E.get(e);if(!t||t.wuwGeneration!==V){t&&i(e,t);const n=new v,r=O(e,n),o=f(k(e),r),{proxy:c,revoke:a}=m(o,N);R(e,c),E.set(e,{mirror:o,remarkedPropertyKeys:n,revoke:a,wuwGeneration:V})}return $}const $=defineFunction("undefined"==typeof self?global:self,"wuw",A),S={get:function(e,t,n){const o=G.get(e);return o&&o.spy===n&&(r(o),n=e),b(e,t,n)},set:function e(t,n,o,i){const c=G.get(t);return c&&c.spy===i?(r(c)?function(t,n,r){const o={target:t,propertyKey:n,stackTrace:_(e),startTime:F()};let i,c;try{i=P(t,n,r),o.success=i}catch(e){c=e,o.error=c}if(o.endTime=F(),u(o),x(o),void 0!==c)throw c;return i}:P)(t,n,o):P(t,n,o,i)}},N={get:function(t,n,r){const c=E.get(r);if(c&&t===c.mirror){if(c.wuwGeneration===V)return function(t,n,r){const i=o(r,t);let c;try{c=b(t,n,r)}finally{R(r,i)}return function(t,n,r){if("style"===n&&function(t){try{e.call(t,-1)}catch(e){return!1}return!0}(r)){let e=G.get(r);if(e)r=e.spy;else{const n=new g(r,S);e={spy:n,wuwTarget:t},G.set(r,e),r=n}}return r}(r,n,c)}(t,n,r);i(r,c)}return b(t,n,r)},set:function e(t,n,r,c){const f=E.get(c);if(f&&t===f.mirror){if(f.wuwGeneration===V)return function({remarkedPropertyKeys:t},n,r,i,c){const f={target:c,propertyKey:r,stackTrace:_(e),startTime:F()},s=o(c,n);let l,d;try{l=P(n,r,i,c),f.success=l}catch(e){d=e,f.error=d}const p=O(c,t);if(a(n,p),R(c,s),f.endTime=F(),u(f),x(f),void 0!==d)throw d;return l}(f,t,n,r,c);i(c,f)}return P(t,n,r,c)}},G=new WeakMap,E=new WeakMap;let V=L();const _=(()=>{const e=n?e=>{const t={};return n(t,e),t.stack.replace(/^.{5}\n/,"")}:()=>t().stack.replace(/^(Error\n)?(?:.*\n){4}/,"");return"stackTraceLimit"in t?n=>{const{stackTraceLimit:r}=t;t.stackTraceLimit=1/0;const o=e(n);return t.stackTraceLimit=r,o}:t=>e(t)})();return defineInterface($,"watching",K),defineFunction($,"watch",A),defineFunction($,"unwatch",C),defineFunction($,"unwatchAll",M),defineFunction(K,"watch",A),defineFunction(K,"unwatch",C),defineFunction(K,"unwatchAll",M),$})();{const e=(e,t)=>{const n=formatList(t.map(formatPropertyKey));M("The target object %o has undeletable properties: %s",e,n)};function formatList(e){let t="",n=0;for(let r=e.length;--r>=0;){switch(n++){case 0:break;case 1:t=` and ${t}`;break;default:t=`, ${t}`}t=e[r]+t}return t}function formatPropertyKey(e){return("string"==typeof e?r:F)(e)}function getRemarkUndeletableProperties(){return I}function setRemarkUndeletableProperties(e){if(void 0!==e&&null!==e&&"function"!=typeof e)throw T("remarkUndeletableProperties must be a function, undefined or null");I=e||null}I=e,defineConstant(N,"defaultRemarkUndeletableProperties",e),defineVariable(N,"remarkUndeletableProperties",getRemarkUndeletableProperties,setRemarkUndeletableProperties),defineConstant(K,"defaultRemarkUndeletableProperties",e),defineVariable(K,"remarkUndeletableProperties",getRemarkUndeletableProperties,setRemarkUndeletableProperties)}const G={};{function do_(e){if(void 0===e)throw T(`Argument of ${j} is missing or undefined`);if("function"!=typeof e)throw T(`Argument of ${j} is not a function`);return $(e),N}function dont(e){if(void 0===e)throw T(`Argument of ${j} is missing or undefined`);if("function"!=typeof e)throw T(`Argument of ${j} is not a function`);return S(e),N}defineInterface(N,"doing",G),defineFunction(N,"do",do_),defineFunction(N,"dont",dont),defineFunction(G,"do",do_),defineFunction(G,"dont",dont)}{let e=0;const t=1e4,n=[],r=()=>{e=0,n.splice(0,1/0)};function getMaxRecords(){return t}function*log(){for(;e<n.length;)yield n[e++]}function logRecord(r){n.length>=t&&(e&&--e,n.shift()),n.push(r)}function setMaxRecords(r){if((r=+r)<0||r!==o(r))throw y("Invalid number of records");t=r+0;const c=n.length-t;c>0&&(e=i(e-c,0),n.splice(0,c))}const c=()=>n.slice();$(logRecord),defineFunction(N,"clear",r),defineConstant(N,"defaultMaxRecords",t),defineFunction(N,"log",log),defineVariable(N,"maxRecords",getMaxRecords,setMaxRecords),defineFunction(N,"snapshot",c)}{let e=null;const t="undefined"!=typeof setImmediate?()=>void setImmediate(printLiveRecords):(()=>{const{port1:e,port2:t}=new MessageChannel;return e.onmessage=printLiveRecords,()=>t.postMessage()})(),n=()=>(S(printLiveRecordLater),N),r=()=>($(printLiveRecordLater),N);function printLiveRecordLater(n){e?e.push(n):(e=[n],t())}function printLiveRecords(){for(;;){const t=e.shift();if(!t)break;C("wuw record\n%o",t)}e=null}{const e=()=>r();defineFunction(e,"on",r),defineFunction(e,"off",n),defineFunction(N,"live",e)}}A=null}